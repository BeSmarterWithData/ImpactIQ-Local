# Define the base folder and script paths at the beginning of the script


$baseFolderPath = "C:\Power BI Backups"


$localFilesFolderPath = "$baseFolderPath\Local Reports and Models"
$Script1Path = "$baseFolderPath\Config\Local Report Detail Extract Script-PBIR.csx"
$Script2Path = "$baseFolderPath\Config\Local Report Detail Extract Script.csx"
$Script3Path = "$baseFolderPath\Config\Local Model Detail Extract Script.csx"
$Script4Path = "$baseFolderPath\Config\Local Measure Dependency Extract Script.csx"

$TabularEditor2Path = "$baseFolderPath\Config\TabularEditor\TabularEditor.exe"

# =============================
# Config
# =============================
$baseFolderPath = "C:\Power BI Backups"
$configFolder   = Join-Path $baseFolderPath "Config"

# Ensure Config exists
if (-not (Test-Path $configFolder)) {
    New-Item -Path $configFolder -ItemType Directory -Force | Out-Null
}

$ErrorActionPreference="SilentlyContinue"; $WarningPreference="SilentlyContinue"

# Temporarily set execution policy to Bypass for this session
if ((Get-ExecutionPolicy) -ne 'Bypass') {
    Write-Host "Temporarily setting Execution Policy to Bypass for this session..."
    Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
}

# =============================
# Download latest pbi-tools
# =============================
$pbiToolsZip = Join-Path $configFolder "PBI Tools.zip"

Write-Host "[INFO] Fetching latest pbi-tools release..."
$pbiRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/pbi-tools/pbi-tools/releases/latest"
$pbiAsset   = $pbiRelease.assets | Where-Object { $_.name -like "*.zip" } | Select-Object -First 1

if ($pbiAsset -and $pbiAsset.browser_download_url) {
    if (Test-Path $pbiToolsZip) { Remove-Item $pbiToolsZip -Force }
    Invoke-WebRequest -Uri $pbiAsset.browser_download_url -OutFile $pbiToolsZip -UseBasicParsing
    Write-Host "[INFO] Downloaded latest pbi-tools to $pbiToolsZip"
} else {
    Write-Warning "[WARN] Could not find a valid pbi-tools zip asset."
}

# =============================
Download latest Tabular Editor 2 Portable
# =============================
$teZip = Join-Path $configFolder "TabularEditor.zip"
$teDownloadUrl = "https://github.com/TabularEditor/TabularEditor/releases/latest/download/TabularEditor.Portable.zip"

Write-Host "[INFO] Downloading latest Tabular Editor 2 Portable..."
if (Test-Path $teZip) { Remove-Item $teZip -Force }
Invoke-WebRequest -Uri $teDownloadUrl -OutFile $teZip -UseBasicParsing
Write-Host "[INFO] Downloaded Tabular Editor 2 Portable to $teZip"

# Define the folder path and zip pattern for PBI Tools
$PBIToolsFolderPath = Join-Path -Path $baseFolderPath\Config -ChildPath "PBI Tools"
$PBIToolsZipPattern = "PBI Tools*.zip"

# Get the first matching zip file
$zipFile = Get-ChildItem -Path $baseFolderPath\Config -Filter $PBIToolsZipPattern | Select-Object -First 1
if ($zipFile) {
    # Remove the folder if it already exists
    if (Test-Path -Path $PBIToolsFolderPath) {
        Remove-Item -Path $PBIToolsFolderPath -Recurse -Force
    }

    # Recreate the folder
    New-Item -Path $PBIToolsFolderPath -ItemType Directory -Force | Out-Null

    # Extract the zip file contents into the folder
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile.FullName, $PBIToolsFolderPath)
    Write-Output "Extracted $($zipFile.Name) to $PBIToolsFolderPath"
}

# Repeat for Tabular Editor
$TabularEditorFolderPath = Join-Path -Path $baseFolderPath\Config -ChildPath "TabularEditor"
$TabularEditorZipPattern = "TabularEditor*.zip"

$zipFile = Get-ChildItem -Path $baseFolderPath\Config -Filter $TabularEditorZipPattern | Select-Object -First 1
if ($zipFile) {
    if (Test-Path -Path $TabularEditorFolderPath) {
        Remove-Item -Path $TabularEditorFolderPath -Recurse -Force
    }

    New-Item -Path $TabularEditorFolderPath -ItemType Directory -Force | Out-Null

    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile.FullName, $TabularEditorFolderPath)
    Write-Output "Extracted $($zipFile.Name) to $TabularEditorFolderPath"
} else {
    Write-Host "No zip file matching the pattern $TabularEditorZipPattern found in $baseFolderPath\Config"
}


$pbiToolsPath = Join-Path -Path $baseFolderPath -ChildPath "Config\PBI Tools\pbi-tools.exe"

# Ensure required modules are installed, and imports them. If import fails, error and exit early
$requiredModules = @( 'ImportExcel', 'MicrosoftPowerBIMgmt' )
foreach ($module in $requiredModules) {
    if( -not (Import-Module $module -PassThru -EA ignore) ) {
       Install-Module -Name $module -Scope CurrentUser -Force
    }

    Import-Module $Module -ErrorAction 'stop' # In the rare case Install-Module fails, you probably want a terminating error
}

# Track script start time
$scriptStartTime = Get-Date








#### Start of Report Backup and VOL Extract ####








# Start Tabular Editor process 1
$p = Start-Process -FilePath "$TabularEditor2Path" -Wait -NoNewWindow -PassThru -WorkingDirectory $localFilesFolderPath -ArgumentList "`"$baseFolderPath\Config\Blank Model.bim`" -S `"$Script1Path`""

# Start Tabular Editor process 2
$p = Start-Process -FilePath "$TabularEditor2Path" -Wait -NoNewWindow -PassThru -WorkingDirectory $localFilesFolderPath -ArgumentList "`"$baseFolderPath\Config\Blank Model.bim`" -S `"$Script2Path`""

# Define the output Excel file path in the parent folder
$outputExcelFile = Join-Path -Path $baseFolderPath -ChildPath "Report Detail.xlsx"

# Check if the Excel file already exists and delete it if it does
if (Test-Path -Path $outputExcelFile) {
    Remove-Item $outputExcelFile -Force
    $excelExists = $false
} else {
    $excelExists = $false
}


foreach ($txtFile in (Get-ChildItem -Path $localFilesFolderPath -Filter *.txt)) {
    $worksheetName = [System.IO.Path]::GetFileNameWithoutExtension($txtFile.FullName)
    
    # Read raw lines without automatically trimming leading or trailing spaces
    $lines = Get-Content -Path $txtFile.FullName -Encoding UTF8
    $headers = $lines[0] -split "`t"
    $data = $lines[1..($lines.Count - 1)] | ForEach-Object {
        $values = $_ -split "`t", -1  # -1 keeps empty trailing fields and preserves spaces
        $obj = @{}
        for ($i = 0; $i -lt $headers.Length; $i++) {
            $obj[$headers[$i]] = $values[$i]
        }
        [PSCustomObject]$obj
    }

    if ($excelExists) {
        $data | Export-Excel -Path $outputExcelFile -WorksheetName $worksheetName -AutoNameRange -Append
    } else {
        $data | Export-Excel -Path $outputExcelFile -WorksheetName $worksheetName -AutoNameRange
        $excelExists = $true
    }
}



Write-Output "TXT files appended to $outputExcelFile"





# -------------------
# Phase 1: Extract PBIX and Generate BIMs
# -------------------

$pbixFiles = Get-ChildItem -Path $localFilesFolderPath -Filter *.pbix -File

foreach ($pbixFile in $pbixFiles) {
    $pbixFilePath = $pbixFile.FullName
    $pbixNameWithoutExtension = [System.IO.Path]::GetFileNameWithoutExtension($pbixFile.Name)

    $extractFolder = Join-Path -Path $localFilesFolderPath -ChildPath $pbixNameWithoutExtension
    $bimGenerated  = Join-Path -Path $extractFolder -ChildPath "$pbixNameWithoutExtension.bim"
    $bimFinalPath  = Join-Path -Path $localFilesFolderPath -ChildPath "$pbixNameWithoutExtension.bim"

    Write-Output "Extracting Model from $pbixNameWithoutExtension"
    & $pbiToolsPath extract $pbixFilePath -extractFolder $extractFolder -modelSerialization Raw

    Write-Host "Generating BIM from extract..."
    & $pbiToolsPath generate-bim $extractFolder -transforms RemovePBIDataSourceVersion

    if (-not (Test-Path $bimGenerated)) {
        Write-Error "Expected BIM not found: $bimGenerated"
        continue
    }

    # Move generated BIM to final location
    Move-Item -Path $bimGenerated -Destination $bimFinalPath -Force
    Write-Host "Generated BIM moved to $bimFinalPath"

    # Clean up extract folder
    if (Test-Path $extractFolder) {
        Remove-Item -Path $extractFolder -Recurse -Force
        Write-Host "Removed extract folder: $extractFolder"
    }
}

# -------------------
# Phase 2: Rename BIMs with Tabular Editor
# -------------------

$bimFiles = Get-ChildItem -Path $localFilesFolderPath -Filter *.bim -File

foreach ($bimFile in $bimFiles) {
    $bimPath = $bimFile.FullName
    $fileNameWithoutExt = [System.IO.Path]::GetFileNameWithoutExtension($bimFile.Name)

    # Build rename C# script
    $csharpScript = @"
Model.Database.Name = "$fileNameWithoutExt";
Model.Database.ID   = "$fileNameWithoutExt";
"@

    $tempScriptPath = Join-Path $env:TEMP "TabularEditor_Rename.cs"
    Set-Content -Path $tempScriptPath -Value $csharpScript -Encoding UTF8

    Write-Host "Renaming Database/ID inside BIM: $bimPath"
    $args = @("`"$bimPath`"", "-S", "`"$tempScriptPath`"", "-B", "`"$bimPath`"")
    Start-Process -FilePath $TabularEditor2Path -Wait -NoNewWindow -ArgumentList $args


    Remove-Item -Path $tempScriptPath -Force
}



#### Start of Model Detail Script Run with Script3Path ####

$bimFiles = Get-ChildItem -Path $localFilesFolderPath -Filter *.bim

foreach ($bimFile in $bimFiles) {
    $bimPath = $bimFile.FullName
    $cleanFileName = [System.IO.Path]::GetFileNameWithoutExtension($bimFile.Name)

    $modelScriptArgs = "`"$bimPath`" -S `"$Script3Path`""
    Start-Process -FilePath "$TabularEditor2Path" -WorkingDirectory $localFilesFolderPath -Wait -NoNewWindow -PassThru -ArgumentList $modelScriptArgs
}

Write-Output "First model export and script run completed."

#### Start of PowerShell Combining to Semantic Models Worksheet ####

$outputExcelFile = Join-Path -Path $baseFolderPath -ChildPath "Model Detail.xlsx"

if (Test-Path -Path $outputExcelFile) {
    Remove-Item $outputExcelFile -Force
}

$semanticModelsCsvData = @()

foreach ($csvFile in (Get-ChildItem -Path $localFilesFolderPath -Filter *.csv)) {
    if ($csvFile.Name -notlike "*_MD.csv") {
        $csvData = Import-Csv -Path $csvFile.FullName
        $semanticModelsCsvData += $csvData
    }
}

$semanticModelsCsvData | Export-Excel -Path $outputExcelFile -WorksheetName "Semantic Models" -AutoNameRange

Write-Output "CSV files combined into the 'Semantic Models' worksheet in $outputExcelFile"

#### Start of Model Detail Script Run with Script4Path ####

foreach ($bimFile in $bimFiles) {
    $bimPath = $bimFile.FullName
    $cleanFileName = [System.IO.Path]::GetFileNameWithoutExtension($bimFile.Name)

    $modelScriptArgs = "`"$bimPath`" -S `"$Script4Path`""
    Start-Process -FilePath "$TabularEditor2Path" -WorkingDirectory $localFilesFolderPath -Wait -NoNewWindow -PassThru -ArgumentList $modelScriptArgs
}

Write-Output "Second model export and script run completed."

#### Start of PowerShell Combining to Measure Dependencies Worksheet ####

$measureDependenciesCsvData = @()

foreach ($csvFile in (Get-ChildItem -Path $localFilesFolderPath  -Filter *_MD.csv)) {
    $csvData = Import-Csv -Path $csvFile.FullName
    $measureDependenciesCsvData += $csvData
}

$measureDependenciesCsvData | Export-Excel -Path $outputExcelFile -WorksheetName "Measure Dependencies" -AutoNameRange -Append

Write-Output "CSV files combined into the 'Measure Dependencies' worksheet in $outputExcelFile"


 # Define the Script Outputs folder
$scriptOutputsFolder = Join-Path -Path $localFilesFolderPath -ChildPath "Script Outputs"

# Create the folder if it doesn't exist
if (-not (Test-Path -Path $scriptOutputsFolder)) {
    New-Item -Path $scriptOutputsFolder -ItemType Directory | Out-Null
}

# Define file extensions to move
$fileExtensions = @("*.txt", "*.csv", "*.bim")

# Move each file type
foreach ($ext in $fileExtensions) {
    $filesToMove = Get-ChildItem -Path $localFilesFolderPath -Filter $ext -File
    foreach ($file in $filesToMove) {
        $destinationPath = Join-Path -Path $scriptOutputsFolder -ChildPath $file.Name
        Move-Item -Path $file.FullName -Destination $destinationPath -Force
    }
}

# Remove all folders in $localFilesFolderPath except $scriptOutputsFolder
$foldersToRemove = Get-ChildItem -Path $localFilesFolderPath -Directory |
    Where-Object { $_.FullName -ne $scriptOutputsFolder }

foreach ($folder in $foldersToRemove) {
    Remove-Item -Path $folder.FullName -Recurse -Force
}

$scriptEndTime = Get-Date
$elapsedTime = New-TimeSpan -Start $scriptStartTime -End $scriptEndTime
Write-Output "Total Elapsed Time: $($elapsedTime.Hours)h $($elapsedTime.Minutes)m $($elapsedTime.Seconds)s"
 
 
